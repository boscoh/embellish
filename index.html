<html>
<head>
    <meta content="initial-scale=1.0" name="viewport">
    <title>embellish - a lightweight static website generator</title>
    <script> window.is_rename = true </script>
<link href="supplescroll.css" rel="stylesheet"><link href="sphinx.css" rel="stylesheet"></head>
<body>
    <div id="banner">embellish - a lightweight static website generator</div>
    <h1>Embellish</h1>
<blockquote>
<p><em>a lightweight static website generator</em></p>
</blockquote>
<p>There are many static website generators out there, but most of them are quite opionated: they demand your posts be put in this directory and your posts ordered in that way, and they often include some tricky custom-defined formats.</p>
<p>Static websites are really quite simple. They&apos;re just a bunch of HTML files in a directory. A static website generator simply transforms text files into HTML files, and includes a few goodies like stylesheets and javascript modules.</p>
<p><code>embellish</code> is a lightweight generator, that can build a website from any directory, transforming any text files it finds into HTML, allowing you to organically grow your website. It&apos;s also very small, and quite easy to modify.</p>
<p>As <code>embellish</code> is designed around the Python ecosystem, it carefully uses standard Python-like indented-text formats, that have been well-tested, namely:</p>
<ul>
<li>markdown for text</li>
<li>YAML front-matter</li>
<li>pug templates</li>
</ul>
<h2>Example Websites Built with Embellish</h2>
<ul>
<li><a href="http://boscoh.com">Bosco Ho&apos;s Emporium of Words</a> - my personal website</li>
<li><a href="http://boscoh.github.io/supplescroll">supplescroll</a> - a document decorator used to build this page</li>
<li><a href="http://boscoh.com/geneparade/human/">the human gene parade</a> - an interactive genome browser</li>
</ul>
<h2>Quick &amp; Dirty Websites</h2>
<p>Other generators dictate your website to be structured their way. <code>embellish</code> does not.</p>
<p>Go to a directory with a <code>markdown</code> file (e.g. the <code>embellish</code> directory):</p>
<pre><code>&gt; embellish .
</code></pre>
<p>Boom!</p>
<p><code>readme.html</code> is generated and opened in a browser.</p>
<p>Now edit <code>readme.txt</code>, save, and refresh the browser.</p>
<h2>Installation</h2>
<p>The project is hosted at <a href="https://github.com/boscoh/embellish">github</a>.</p>
<p>Have <code>node</code> installed? Then:</p>
<pre><code>  &gt; npm install -g embellish
</code></pre>
<p>Or install manually using the <a href="https://github.com/boscoh/embellish/archive/master.zip">zip file</a>:</p>
<pre><code>&gt; npm link
</code></pre>
<p>All the following examples can be found in the <code>examples</code> directory of the zip file.</p>
<h2>Blog with Categories</h2>
<p>Any litmus test for a static website generator is to make a blog. Here&apos;s a quick guide using <code>embellish</code> where <code>markdown</code> is used for the text, <code>YAML</code> for metadata, and <code>haml</code> to write the HTML.</p>
<p><code>embellish</code> will recognize files with extensions <code>.txt</code>, <code>.md</code>, <code>.mkd</code> and <code>.markdown</code> as post/article pages.</p>
<h3>Article page</h3>
<p><code>embellish</code> expects a text page with an optional YAML front-matter defined  by <code>---</code>  such as in <code>post.mkd</code> <a href="#fig-post"></a>.</p>
<div id="fig-post">
  <code>post.mkd</code> - example of a Markdown Post
<pre><code>---
title: The Title of this Post
template: post.pug
---
# Great Post in Markdown

## Markdown Sub-headers!

This is the _body_ of the text 
written in markdown
</code></pre>
</div>
<p>The front-matter is optional. <code>embellish</code> reads the header as <a href="https://github.com/Animosity/CraftIRC/wiki/Complete-idiot&apos;s-introduction-to-yaml">YAML</a> metadata. There are a few fields used by <code>embellish</code> but you can add anything you want. This metadata will be made available to you in the template as a dictionary called <code>page</code>.</p>
<p>To generate an HTML page from this article post, a template is required. In this case, the template referred to in the header is <code>post.pug</code>. If no template is given, a default one is used that is located in the embllish directory under <code>defaults/default.pug</code>.</p>
<h3>Templates and Style Sheets</h3>
<p>Templates are used to generate HTML files from text files and their attendant header information.</p>
<p><code>embellish</code> uses <a href="https://pugjs.org/api/getting-started.html">pug</a> templates. A simple example is <code>post.pug</code> <a href="#fig-template"></a>, which was referred in <code>post.txt</code> above.</p>
<div id="fig-template"> 
  <code>post.pug</code> - example of a simple HAML template to generate an article HTML
<pre><code>head
  link(href=&apos;styles.css&apos; rel=&apos;stylesheet&apos;)
body
  .title
    | #{ page.title }
  .nav
    | category: 
    | #{ page.category } &amp;#183;
    | published: 
    | #{ page.date }#
  hr
  | !{ page.content }
</code></pre>
</div>
<p>For details on how templates work in <code>embellish</code>, see the Template Guide below.</p>
<p>Notice that there is a link to a style sheet <code>styles.css</code> <a href="#fig-template"></a>. Now, you could simply creat your own <code>styles.css</code> and put it in the directory, but I strongly recommend you to write <a href="https://github.com/boscoh/sassin">SASS</a> style sheets such as <code>styles.sass</code> <a href="#fig-sass"></a>, and use <a href="http://sass-lang.com/"><code>sass</code></a> to compile into <code>styles.css</code>. <strong>note</strong> in previous versions, this was done for you but it was rather fragile and difficult to debug. Now, you should just compile to css yourself.</p>
<div id="fig-sass"> 
  <code>style.sass</code> - a SASS file to generate <code>style.css</code>
<pre><code>body
  background-color: #FFF
  font-family: Helvetica
  width: 450px
  margin: 40px auto
.title
  text-transform: uppercase
  font-weight: 900
  font-size: 18px
  letter-spacing: 0.1em
.nav
  font-style: italic
  font-size: 12px
</code></pre>
</div>
<p>With the post, the template, and the style sheet done, we are now ready to make the blog:</p>
<pre><code>&gt; embellish .
</code></pre>
<p>Open <code>post.html</code> in your browser.</p>
<h3>Index Pages</h3>
<p>To really get the blog going, though, we will need to build an index page to list a bunch of posts. First, we create a text file that will generate an index of posts <code>index.mkd</code> <a href="#fig-index-mkd"></a>.</p>
<div id="fig-index-mkd"> <code>index.mkd</code> - example of a markdown file that generates a blog index file
<pre><code>---
template: index.pug
index: True
sortKey: date
sortReverse: True
maxSubpages: 5
title: Blog Posts
---
Some words to describe the following list of 
posts that are arranged in reverse chronological 
order.
</code></pre>
</div>
<p>In the header of the post, the key flag is:</p>
<pre><code>index: True
</code></pre>
<p>which tells <code>embellish</code> to send a list of posts into the template during compilation of the HTML file. Since in this case, no <code>category</code> was given, all the posts found by <code>embellish</code> will be used.</p>
<p>The posts will be sorted by date as indicated by:</p>
<pre><code>sortKey: date
</code></pre>
<p>Any other field could have been used, but let&apos;s start with date. We&apos;d also like to do it in reverse order as fits blogging convention:</p>
<pre><code>sortReverse: True
</code></pre>
<p>And we don&apos;t want too many posts, so</p>
<pre><code>maxSubpages: 5
</code></pre>
<h3>Templating Index Pages</h3>
<p>Okay now the text file is done, let&apos;s make the template for an index file <code>index.pug</code> <a href="#fig-index-haml"></a>.</p>
<div id="fig-index-haml"> <code>index.pug</code> - example of a HAML template that generates the HTML code for an index markdown file
<pre><code>head
  link(href=&apos;styles.css&apos; rel=&apos;stylesheet&apos;)
body
  .title
    | #{ page.title }
  | !{ page.content }
  ul  
    each subpage in page.subpages
      li
        b
          a(href= `${subpage.relSiteUrl}/${subpage.url}`)= subpage.title
        br
        i= subpage.excerpt
        br
        .nav
          if subpage.category
            | category: #{ subpage.category }
            br
          | date: #{subpage.date}
        br
        br

</code></pre>
</div>
<p>How it works is that during compilation, <code>embellish</code> will package all the information for the page into a dictionary <code>page</code> and send it into the template. As well another dictionary <code>site</code> will also be sent that includes the site configuration information. These will be described in detail below in the Templating Guide.</p>
<p>The header of the template is pretty similar to <code>post.pug</code> <a href="#fig-template"></a> above, with the big difference in that <code>index.pug</code> <a href="#fig-index-haml"></a> can handle a special field called <code>page.subpages</code>.</p>
<p><code>page.subpages</code> holds a list of all the pages found by <code>embellish</code> that belong to this index page. If a <code>category</code> was given, then only pages with the same <code>category</code> will be kept in the list. Here, since no <code>category</code> was given, all pages are given.</p>
<p>To handle the display of all the <code>page.subpages</code>, there is a pug control loop:</p>
<pre><code>each subpage in page.subpages
    | #{ subpage.title }
    | #{ subpage.excerpt }
</code></pre>
<p><strong>Note</strong>: it&apos;s important you use <code>subpage</code> as the looping variable, as <code>page</code> would otherwise clash with the main <code>page</code> dictionary.</p>
<p>You might have noticed that there is no pagination. I hate pagination, so I did not implement it. Just put all posts in one page.</p>
<h3>Referring to URLs</h3>
<p>It&apos;s important to get the URL&apos;s right to show up in the template.</p>
<p>First we need the site URL, and there are two ways to get it:</p>
<ol>
<li>The site&apos;s absolute URL, which is <code>#{ site.url }</code></li>
<li>The site&apos;s relative URL which depends on the location of the page in question <code>#{page.relSiteUrl}</code></li>
</ol>
<p>The URL of a page thus combines the site&apos;s URL with the page&apos;s URL.</p>
<p>If you want the absolute URL, you can construct the url using this interpolated string (notice the use of back-ticks):</p>
<pre><code>`${site.url}/${page.url}` 
</code></pre>
<p>For the relative URL of a page, which is more flexible, but more prone to breaking during deployment :</p>
<pre><code>`${site.relSiteUrl}/${page.url}` 
</code></pre>
<p>In <code>index.pug</code> <a href="#fig-index-haml"></a>, relative links are used for the <code>subpage</code> in the looping through the collected posts, so the link is:</p>
<pre><code>`${subpage.relSiteUrl}/${supbage.url}`
</code></pre>
<h3>Archiving With Categories</h3>
<p>Now with blog posts, you might want to archive posts under different categories.</p>
<p>Let&apos;s say you have a post about vampires <code>vampire.mkd</code> <a href="#fig-vampire-post"></a>. You give it a category in the header by:</p>
<pre><code>category: vampire
</code></pre>
<div id="fig-vampire-post"> <code>vampire.mkd</code> - a post with a category of vampire.
<pre><code>---
title: The Vampire Post
template: post.pug
category: vampire
---
# This is Vampire Post

## There&apos;s Vampire as Category!

This is also in __markdown__.
</code></pre>
</div>
<div id="fig-archive-index"> <code>archive.mkd</code> - a post with a category of vampire.
<pre><code>---
template: index.pug
index: True
sortKey: date
category: vampire
sortReverse: True
title: Archive of Posts about Vampires
---
</code></pre>
</div>
<p>Then, to collect all your vampire posts in an archive, you can create an index file <code>archive.mkd</code> <a href="#fig-archive-index"></a>, where the only difference from <code>index.mkd</code> <a href="#fig-index-mkd"></a>, is that a category is given:</p>
<pre><code>category: vampire
</code></pre>
<p>And then you run:</p>
<pre><code>&gt; embellish .
</code></pre>
<p>Which will generate an index post of all pages in <code>index.html</code> and an archive page for vampire posts <code>archive.html</code>.</p>
<h2>Larger Websites</h2>
<h3>Configuration Files</h3>
<p>Obviously for a more complicated website, you want to separate your content, templates, assets, and output into different directories.</p>
<p>To tell <code>embellish</code> where the directories are, you create a configuration file in the YAML format, such as <code>site.yaml</code> <a href="#fig-config"></a>:</p>
<div id="fig-config"> <code>site.yaml</code> a YAML configuration file for a larger website
<pre class="codehilite">
url: http://boscoh.com # if  then use relative urls
contentDir: content  # look for markdown files
templateDir: templates  # look for templates
cachedPages: site.cache
outputDir: site  # generated files and static files put here
recursive: True # recursively searches through directories
mediaDir: media  # files to be copied directly into the output directory
writeExt: .html
</pre>
</div>
<p>To whit:</p>
<ul>
<li><code>url</code>: the hard-coded URL of your website. If given, this is available in any templates you make as <code>site.url</code>.</li>
<li><code>contentDir</code>: the directory where you put all your posts and index files.</li>
<li><code>templateDir</code>: for holding templates</li>
<li><code>mediaDir</code>: your supporting files - javascript, css style sheets, images, movies, etc. These will be copied directly into the <code>outputDir</code></li>
<li><code>outputDir</code>: the directory where all compiled contents and contents of <code>mediaDir</code> are put</li>
<li><code>writeExt</code>: the extension for the html files, typically <code>.html</code> or <code>.htm</code></li>
</ul>
<p>To run <code>embellish</code> against this configuration file:</p>
<pre><code>embellish site.yaml
</code></pre>
<p>And the result will be in the <code>outputDir</code>.</p>
<p>Note: when using <code>embellish</code> with a directory as the argument, such as:</p>
<pre><code> &gt; embellish .
</code></pre>
<p>Internally, <code>embellish</code> sets these fields in <code>site</code> - <code>contentDir</code>, <code>templateDir</code>, <code>mediaDir</code>, <code>outputDir</code> - to the current directory. <code>embellish</code> will skip the copying of files, and thus the website is made in place!</p>
<h3>Recursive Directory Processing</h3>
<p>Since <code>embellish</code> is meant to be a quick-and-dirty website generator, the default is to search only in the directory specified for content files.</p>
<p>This avoids accidentally telling <code>embellish</code> to search through a very large forest of subdirectories.</p>
<p>But you can tell <code>embellish</code> to exhaustively process all subdirectories with the <code>-r</code> option:</p>
<pre><code>&gt; embellish -r .
</code></pre>
<h2>Templating guide</h2>
<p>To write custom templates in <code>jinja2-haml</code>, you&apos;ll have to understand the data model <code>embellish</code> uses to compile templates.</p>
<p>During compilation, two dictionaries are passed into every template:</p>
<ol>
<li>
<p><code>site</code>: contains all the settings for the entire site. This includes all the source directories, site url, and is essentially, the information in the <code>site.yaml</code> <a href="#fig-config"></a> configuration file.</p>
</li>
<li>
<p><code>page</code>: contains all the information of a given page, including <code>subpages</code> when the <code>page</code> is an index.</p>
</li>
</ol>
<h3>Page Metadata</h3>
<p>Every <code>page</code> dictionary comes equiped with a set of default metadata. The best way to show this is from the Python source code <a href="#fig-page-dictionary"></a>:</p>
<div id="fig-page-dictionary"> <code>page</code> - the python dictionary that is piped into every template
<pre><code>let defaultPage = {
  template: &apos;default.pug&apos;,  // name of template file
  filename: null,  // name of markdown file
  checksum: &apos;&apos;, // checksum used to check final output to avoid redundant writes
  excerpt: &apos;&apos;, // text to put in excerpt, no tags please!
  content: &apos;&apos;,  // main text of article
  title: &apos;&apos;,  // title for indexing and for large display
  category: &apos;&apos;,  // category of article for indexing
  relSiteUrl: &apos;&apos;,  // the top site directory relative to this page
  dateFormatString: null, // dateFormat formatting string
  date: null,  // published date
  slug: null,  // url-safe name of article used to make url and files
  url: &apos;&apos;,   // relative url used for links in index files
  target: &apos;&apos;,    // target filename, maybe different to url due to redirection
  index: false,   // indicates if this is an indexing page
  sortKey: null,  // the field on which to sort under in indexing
  sortReverse: true,  // ascending or descing order for sorting
  subpages: [],   // in indexing, pages belonging to the index placed here
  maxSubpages: null,  // a maximum limit of files to put in subpages
};
</code></pre>
</div>
<p>This relevant fields in the <code>page</code> dictionary is then overriden by the YAML header of the corresponding source file.</p>
<p>In a <code>pug</code> template, these fields are accessible in the form of:</p>
<pre><code>#{ page.title }
</code></pre>
<p>In particular, dates are converted to standard Python datetime objects, and can be passed into the jinja templates by calling the datetime string method:</p>
<pre><code>#{ page.date }
</code></pre>
<p>If excerpts are not given, <code>page.excerpt</code> is set to the first 50 non-tag words in the main text.</p>
<h3>Filenames and Directory Structure</h3>
<p>Two design principles of <code>embellish</code> is that it lets you determine the URL and file placement as much as possible, and that relative URLs should work. No matter what, <code>page.target</code> will contain the filename of the target HTML file, which is written in the <code>site.outputDir</code> directory. If <code>page.url</code> or <code>page.target</code> are specified, these will be used.</p>
<p>Most of the time <code>page.url</code> will match <code>page.target</code>. If <code>page.url</code> is not specified, then it is assumed that the path of the markdown file with respect to the <code>site.contentDir</code> represents the <code>page.url</code> and the <code>page.target</code>. In flat-file mode, this means the <code>.html</code> file will appear in the same directory as the markdown file.</p>
<p>A common exception to this are index.html files in subdirectories. Because browsers default to <code>dir/</code> for <code>dir/index.html</code>, a useful motif in the header for <code>index.html</code> files is:</p>
<pre><code>url: archive/
target: archive/index.html
</code></pre>
<p>Two other fields need to be mentioned. Sometimes legitimate filenames cannot serve as URLs, so a conversion is done to turn the basename of the filename into a <code>page.slug</code>. This can be directly overriden if the <code>page.slug</code> field is given.</p>
<p>Finally, the extension of the output files are normally assumed to be <code>.html</code> but this can be overriden in <code>site.ext</code> in the configuration file.</p>
<h3>Absolute &amp; Relative URLs</h3>
<p>To reiterate, the site&apos;s URL is given in:</p>
<ol>
<li>an absolute form <code>#{site.url}</code></li>
<li>a relative form, relative to the page <code>#{page.relSiteurl}</code></li>
</ol>
<p>Where for instance if <code>embellish</code> was run in the current directory, and so is the file, then:</p>
<pre><code>page.relSiteurl = &apos;&apos;
</code></pre>
<p>The page&apos;s URL is thus a combination of the site URL and the page&apos;s relative URL:</p>
<ol>
<li>absolute: <code>`${site.url }/${ page.url}`</code></li>
<li>relative <code>`${page.relSiteurl}/${ page.url}`</code></li>
</ol>

<script src="supplescroll.min.js"></script></body>
</html>